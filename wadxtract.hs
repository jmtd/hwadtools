import System.Environment (getArgs)
import System.IO
import System.Directory (createDirectoryIfMissing)
import qualified Data.ByteString.Lazy as L
import qualified Data.ByteString.Lazy.Char8 as C -- unpack
import Data.Binary.Get
import System.FilePath --(</>)

import Wad

-- lumps related to a particular map that must be clogged together
-- thanks, deutex
-- also: MAP.., E.M.,  GL_MAP.. (etc)
maplumps = [ "BEHAVIOR"  -- Hexen only (and zdoom?)
           , "BLOCKMAP"
           , "DIALOGUE"  -- UDMF
           , "ENDMAP"  -- UDMF
           , "FLATNAME"  -- Doom alpha 0.4 and 0.5 only
           , "LINEDEFS"
           , "LINES"  -- Doom alpha 0.4 and 0.5 only
           , "NODES"
           , "POINTS"  -- Doom alpha 0.4 and 0.5 only
           , "REJECT"  -- Not in Doom PR
           , "SECTORS"
           , "SEGS"
           , "SIDEDEFS"
           , "SSECTORS"
           , "TEXTMAP"  -- UDMF
           , "THINGS"
           , "VERTEXES"
           , "ZNODES"  -- UDMF
           -- missing from deutex (generated by glbsp)
           , "GL_VERT"
           , "GL_SEGS"
           , "GL_SSECT"
           , "GL_NODES"
           , "GL_PVS"
           ]

usage = do
    error "usage: blah"

getHandle = do
    args <- getArgs
    handle <- if length args /= 2
              then usage
              else openFile (head args) ReadMode
    hSetBinaryMode handle True
    return (handle, args !! 1)

{-
  what info do we need to record in wadinfo.txt in order to faithfully recreate the WAD?
  can we rely on the directory entries being in the right order (ascending offsets?) no.
  thus we need to write the offsets.
  can we infer the lump size from the file on disk? yes... except, if we have some janky
  overlapping offsets and a resource is changed later... can we handle that situation?
  so we just need rawname (since we want reproducibility) and offset, it seems.
-}
-- XXX this is bad, unpack will fuck up non-ascii chars I think?
wadInfoEntry :: DirEnt -> String
wadInfoEntry (offs,size,rawname) = (C.unpack rawname) ++ "," ++ (show offs)

writewadInfo dirents outdir =
    writeFile (outdir </> "wadinfo.txt") (unlines (map wadInfoEntry dirents))

-- XXX problem: rawname is being truncated at the first \0 here so we need a mapping fn instead
-- XXX another problem: lump names could clash, we need to distinguish them somehow
-- XXX another problem: we need to recognise MAP markers and bundle such lumps together
writeLump :: L.ByteString -> FilePath -> DirEnt -> IO ()
writeLump input outdir (offs',size',rawname) = do
    L.writeFile fn lump where
        fn = outdir </> (C.unpack rawname)
        lump = L.take size (L.drop offs input)
        size = fromIntegral size'
        offs = fromIntegral offs'

writeLumps :: L.ByteString -> FilePath -> [DirEnt] -> IO ()
writeLumps input outdir dirents = mapM_ (writeLump input outdir) dirents

extractWad handle outdir = do
    input  <- L.hGetContents handle
    let (numents,waddir) = runGet getWadDirectory input
    let dirents = runGet (parseDirectory numents) waddir
    writewadInfo dirents outdir
    writeLumps input outdir dirents

main = do
    (handle, outdir) <- getHandle
    createDirectoryIfMissing True outdir
    extractWad handle outdir
